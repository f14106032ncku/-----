// 初始化與存入值
0000000_00000_00000_000_00101_0010011 // addi x5, x0, 0       #0 x5 = 0 (記憶體索引外層迴圈索引)
0000000_00001_00000_000_00110_0010011 // addi x6, x0, 1       #1 x6 = 1
0000000_00110_00101_010_00000_0100011 // sw x6, x5, 0         #2 MEM[0] = 1
0000000_00011_00000_000_00110_0010011 // addi x6, x0, 3       #3 x6 = 3 
0000000_00110_00101_010_00001_0100011 // sw x6, x5, 1         #4 MEM[1] = 3
0000000_00110_00000_000_00110_0010011 // addi x6, x0, 6       #5 x6 = 6 
0000000_00110_00101_010_00010_0100011 // sw x6, x5, 2         #6 MEM[2] = 6
0000000_00010_00000_000_00110_0010011 // addi x6, x0, 2       #7 x6 = 2 
0000000_00110_00101_010_00011_0100011 // sw x6, x5, 3         #8 MEM[3] = 2 
0000000_00100_00000_000_00110_0010011 // addi x6, x0, 4       #9 x6 = 4 (迴圈總數)
0000000_00110_00101_010_00100_0100011 // sw x6, x5, 4         #10 MEM[4] = 4 

// 排序開始
// 外層迴圈：x5 為外層索引
0000000_00000_00000_000_00111_0010011 // addi x7, x0, 0       #11 x7 = 0 (內層索引)

// 內層迴圈開始
// 比較 MEM[x7] 與 MEM[x7 + 1]
0000000_00000_00111_010_00001_0000011 // lw x1, x7, 0         #12 載入 MEM[x7] 到 x1
0000000_00001_00111_010_00010_0000011 // lw x2, x7, 1         #13 載入 MEM[x7 + 1] 到 x2
0000000_00000_00000_000_00000_0000000 //                      #14
0_000000_00010_00001_100_0011_0_1100011 // blt x1, x2, 15+3   #15 如果 x1 < x2，跳過交換
0000000_00001_00111_010_00001_0100011 // sw x1, x7, 1         #16 交換：MEM[x7 + 1] = x1
0000000_00010_00111_010_00000_0100011 // sw x2, x7, 0         #17 交換：MEM[x7] = x2

// 更新內層索引
0000000_00001_00111_000_00111_0010011 // addi x7, x7, 1       #18 x7 += 1
1_111111_00111_00110_101_1001_1_1100011 // bge x7, x6, 19-7     #19 如果 x7 >= x6，跳出內層迴圈

// 更新外層索引
0000000_00001_00101_000_00101_0010011 // addi x5, x5, 1       #20 x5 += 1
1_111111_00101_00110_101_0110_1_1100011 // bge x5, x6, 21-10    #21 如果 x5 >= x6，跳出排序


